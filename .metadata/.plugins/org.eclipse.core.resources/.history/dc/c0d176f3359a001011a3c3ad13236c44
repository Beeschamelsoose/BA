#include "save.h"
#include <string.h>

/* === Flash-Layout === */
#define FLASH_PAGE_SIZE        2048u
#define FLASH_DATA_PAGE_ADDR   0x0801F800u  // letzte Page bei 128KB

/* === Record-Puffer ===
 * 2048 / 12 = 170 Records (2040 B), 8 B Padding pro Page
 */
#define RECORD_SIZE            ((uint32_t)sizeof(DataRecord))
#define MAX_RECORDS_PER_PAGE   (FLASH_PAGE_SIZE / RECORD_SIZE)   // 170

static DataRecord s_ramBuf[MAX_RECORDS_PER_PAGE];
static uint16_t   s_ramIdx = 0;

/* Hilfsfunktion: absolute Flash-Seitennummer */
static inline uint32_t flash_page_index(uint32_t addr) {
    return (addr - 0x08000000u) / FLASH_PAGE_SIZE;
}

void Save_Init(void) {
    s_ramIdx = 0;
    memset(s_ramBuf, 0xFF, sizeof(s_ramBuf));
}

/* Append in den RAM-Puffer; bei Voll -> Flush */
HAL_StatusTypeDef Save_Append(const DataRecord *rec) {
    s_ramBuf[s_ramIdx] = *rec;
    s_ramIdx++;

    if (s_ramIdx >= MAX_RECORDS_PER_PAGE) {
        return Save_Flush();
    }
    return HAL_OK;
}

/* RAM → Flash (ganze 2KB-Page) */
HAL_StatusTypeDef Save_Flush(void) {
    HAL_StatusTypeDef st = HAL_OK;

    /* 2KB-Page-Image vorbereiten: 170*12=2040 B Daten + 8 B 0xFF Padding */
    static uint8_t pageImg[FLASH_PAGE_SIZE];
    uint32_t used_bytes = (uint32_t)s_ramIdx * RECORD_SIZE; // i.d.R. 2040
    if (used_bytes > FLASH_PAGE_SIZE) used_bytes = FLASH_PAGE_SIZE;

    /* alles auf 0xFF, dann Records vorne dran kopieren */
    memset(pageImg, 0xFF, sizeof(pageImg));
    memcpy(pageImg, s_ramBuf, used_bytes);

    /* Flash entsperren */
    HAL_FLASH_Unlock();

    /* Page löschen */
    FLASH_EraseInitTypeDef er = {
        .TypeErase = FLASH_TYPEERASE_PAGES,
        .Page      = flash_page_index(FLASH_DATA_PAGE_ADDR),
        .NbPages   = 1
    };
    uint32_t page_err = 0;
    st = HAL_FLASHEx_Erase(&er, &page_err);
    if (st != HAL_OK) {
        HAL_FLASH_Lock();
        return st;
    }

    /* Page in 64-bit Doublewords schreiben */
    for (uint32_t off = 0; off < FLASH_PAGE_SIZE; off += 8) {
        /* STM32L4: 8-Byte aligned doubleword write */
        uint64_t dw;
        memcpy(&dw, &pageImg[off], 8);
        st = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
                               FLASH_DATA_PAGE_ADDR + off,
                               dw);
        if (st != HAL_OK) {
            break;
        }
    }

    HAL_FLASH_Lock();

    /* RAM-Puffer zurücksetzen */
    s_ramIdx = 0;
    memset(s_ramBuf, 0xFF, sizeof(s_ramBuf));

    return st;
}

/*packen von ADC+Status.
 */
HAL_StatusTypeDef save_push_from_main_ts(int8_t t1, int8_t t2, int8_t t3,
                                         int8_t h1, int8_t h2, int8_t h3,
                                         uint16_t adc12, uint8_t st,
                                         uint8_t reserved, uint16_t ts)
{
    DataRecord rec;
    rec.timestamp = (uint32_t)ts;
    rec.temp[0]   = t1; rec.temp[1] = t2; rec.temp[2] = t3;
    rec.hum[0]    = h1; rec.hum[1]  = h2; rec.hum[2]  = h3;

    /* >>> DEINE 2 ZEILEN (Packen 12b ADC + 4b Status) <<< */
    uint16_t adc_state = (uint16_t)((adc12 & 0x0FFFu) | ((st & 0x0Fu) << 12));
    rec.adc_state = adc_state;

    (void)reserved; // aktuell ungenutzt
    return Save_Append(&rec);
}
