/*
 * save.c
 *
 *  Created on: Aug 27, 2025
 *      Author: ernst
 */

#include "save.h"
#include "stm32l4xx_hal.h"
#include <string.h>

/* Adresse der letzten Flash-Page (2 KB) bei STM32L432KC mit 128 KB Flash */
#define FLASH_DATA_PAGE_ADDR   0x0801F800U
#define FLASH_PAGE_SIZE        2048
#define RECORD_SIZE            sizeof(DataRecord)
#define MAX_RECORDS            (FLASH_PAGE_SIZE / RECORD_SIZE)

/* RAM-Puffer */
static DataRecord ramBuffer[MAX_RECORDS];
static uint16_t ramIndex = 0;

/* --- Initialisierung --- */
void Save_Init(void) {
    ramIndex = 0;
    memset(ramBuffer, 0xFF, sizeof(ramBuffer));
}

/* --- Neuen Datensatz in RAM puffern --- */
HAL_StatusTypeDef Save_Append(DataRecord *rec) {
    ramBuffer[ramIndex] = *rec;
    ramIndex++;

    if (ramIndex >= MAX_RECORDS) {
        return Save_Flush();   // RAM -> Flash
    }
    return HAL_OK;
}

/* --- RAM-Puffer ins Flash schreiben --- */
HAL_StatusTypeDef Save_Flush(void) {
    HAL_StatusTypeDef status = HAL_OK;
    FLASH_EraseInitTypeDef eraseInit;
    uint32_t pageError = 0;

    HAL_FLASH_Unlock();

    /* Flash-Page löschen */
    eraseInit.TypeErase   = FLASH_TYPEERASE_PAGES;
    eraseInit.Page        = (FLASH_DATA_PAGE_ADDR - 0x08000000U) / FLASH_PAGE_SIZE;
    eraseInit.NbPages     = 1;

    status = HAL_FLASHEx_Erase(&eraseInit, &pageError);
    if (status != HAL_OK) {
        HAL_FLASH_Lock();
        return status;
    }

    /* Page mit RAM-Puffer füllen */
    for (uint32_t i = 0; i < MAX_RECORDS; i++) {
        uint64_t data64;
        memcpy(&data64, &ramBuffer[i], sizeof(DataRecord));

        status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
                                   FLASH_DATA_PAGE_ADDR + i * RECORD_SIZE,
                                   data64);
        if (status != HAL_OK) {
            break;
        }
    }

    HAL_FLASH_Lock();

    /* Nach dem Schreiben RAM-Puffer leeren */
    ramIndex = 0;
    memset(ramBuffer, 0xFF, sizeof(ramBuffer));

    return status;
}

