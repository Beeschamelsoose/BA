#include "save.h"
#include <string.h>
#include <stdio.h>
#include "stm32l4xx_hal.h"

/* ========= KONFIGURATION =========
 * STM32L432KC: 256 kB Flash, davon obere 128 kB (64 Pages à 2 kB)
 * werden für Datenspeicherung genutzt.
 */
#define DATA_FLASH_START_ADDR   0x08020000u
#define DATA_FLASH_NUM_PAGES    64u
#define FLASH_PAGE_SIZE         2048u
#define PAGE_MAGIC              0xA55Au

typedef struct __attribute__((packed)) {
    uint16_t magic;         // Kennung "gültige Page"
    uint16_t session_flag;  // eindeutige Messreihen-ID
    uint32_t reserved;      // ungenutzt (0xFFFFFFFF)
} PageHeader;

#define PAGE_HEADER_SIZE        sizeof(PageHeader)
#define RECORD_SIZE             ((uint32_t)sizeof(DataRecord))
#define RECORDS_PER_PAGE        ((FLASH_PAGE_SIZE - PAGE_HEADER_SIZE) / RECORD_SIZE)

/* ====== interne Zustände ====== */
static DataRecord buffer[RECORDS_PER_PAGE];
static uint16_t   buffer_index = 0;
static uint16_t   session_flag = 0;
static uint32_t   start_page   = 0;
static uint32_t   current_page = 0;
static uint8_t    storage_full = 0;
static uint16_t		page_counter=0;

extern ADC_HandleTypeDef hadc1;

/* ===== Flash-Helfer ===== */
static inline uint32_t page_index_to_addr(uint32_t i) {
    return DATA_FLASH_START_ADDR + i * FLASH_PAGE_SIZE;
}

static int page_is_erased(uint32_t addr) {
    const uint64_t *p = (const uint64_t*)addr;
    for (uint32_t i = 0; i < FLASH_PAGE_SIZE / 8; i++) {
        if (p[i] != 0xFFFFFFFFFFFFFFFFULL) return 0;
    }
    return 1;
}

static HAL_StatusTypeDef erase_page(uint32_t page_idx) {
    HAL_FLASH_Unlock();
    FLASH_EraseInitTypeDef erase;
    erase.TypeErase = FLASH_TYPEERASE_PAGES;
    erase.Page = (DATA_FLASH_START_ADDR - FLASH_BASE) / FLASH_PAGE_SIZE + page_idx;
    erase.NbPages = 1;
    uint32_t error = 0;
    HAL_StatusTypeDef st = HAL_FLASHEx_Erase(&erase, &error);
    HAL_FLASH_Lock();
    return st;
}

static HAL_StatusTypeDef program_doubleword(uint32_t addr, uint64_t data) {
    HAL_StatusTypeDef st;
    HAL_FLASH_Unlock();
    st = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, addr, data);
    HAL_FLASH_Lock();
    return st;
}

/* ===== Session-Flag aus ADC-Rauschen erzeugen ===== */
static uint16_t generate_session_flag(void) {
    uint16_t v = 0;
    if (HAL_ADC_Start(&hadc1) == HAL_OK) {
        if (HAL_ADC_PollForConversion(&hadc1, 10) == HAL_OK)
            v ^= (uint16_t)HAL_ADC_GetValue(&hadc1);
        HAL_ADC_Stop(&hadc1);
    }
    v ^= (uint16_t)HAL_GetTick();
    v ^= (uint16_t)(READ_REG(*((uint32_t*)UID_BASE)));
    if (v == 0 || v == 0xFFFF) v ^= 0xBEEF;
    return v;
}

/* ===== Freie Start-Page finden ===== */
static uint32_t find_start_page(void) {
    for (uint32_t i = 0; i < DATA_FLASH_NUM_PAGES; i++) {
        if (page_is_erased(page_index_to_addr(i))) return i;
    }
    return 0; // alles voll -> alte Messung überschreiben
}

/* ===== Eine Page schreiben ===== */
static HAL_StatusTypeDef flush_page(void) {
    if (storage_full) return HAL_BUSY;

    uint32_t addr = page_index_to_addr(current_page);
    static uint64_t pagebuf[FLASH_PAGE_SIZE / 8];
    for (uint32_t i = 0; i < FLASH_PAGE_SIZE / 8; i++) pagebuf[i] = 0xFFFFFFFFFFFFFFFFULL;

    PageHeader hdr = { .magic = PAGE_MAGIC, .session_flag = session_flag, .reserved = 0xFFFFFFFF };
    memcpy((uint8_t*)pagebuf, &hdr, sizeof(hdr));
    if (buffer_index > 0)
        memcpy((uint8_t*)pagebuf + PAGE_HEADER_SIZE, buffer, buffer_index * sizeof(DataRecord));

    HAL_StatusTypeDef st = erase_page(current_page);
    if (st != HAL_OK) return st;

    for (uint32_t off = 0; off < FLASH_PAGE_SIZE; off += 8) {
        st = program_doubleword(addr + off, pagebuf[off / 8]);
        if (st != HAL_OK) return st;
    }

    uint32_t next = (current_page + 1) % DATA_FLASH_NUM_PAGES;
    if (next == start_page) storage_full = 1;  // Stop-Bedingung
    else current_page = next;
    buffer_index = 0;

    /* Debug: Page-Zähler und Status ausgeben */
    page_counter++;
    printf("[SAVE] Page %lu geschrieben (Index %lu, %lu kB genutzt)\r\n",
           (unsigned long)page_counter,
           (unsigned long)current_page,
           (unsigned long)(page_counter * 2));

    if (page_counter >= DATA_FLASH_NUM_PAGES) {
        printf("[SAVE] *** Speicher voll: 128 kB erreicht! ***\r\n");
    }

    /* Nächste Page vorbereiten */
    uint32_t next = (current_page + 1) % DATA_FLASH_NUM_PAGES;
    if (next == start_page) {
        storage_full = 1;  // Stop-Bedingung
        printf("[SAVE] *** Speicherung gestoppt: Runde komplett voll ***\r\n");
    } else {
        current_page = next;
    }
}

/* ===== Öffentliche Funktionen ===== */
void Save_Init(void) {
    storage_full = 0;
    buffer_index = 0;
    start_page = find_start_page();
    current_page = start_page;
    session_flag = generate_session_flag();

    /* leere Headerseite schreiben, um Session-Flag zu sichern */
    flush_page();
}

HAL_StatusTypeDef Save_Append(const DataRecord *rec) {
    if (storage_full) return HAL_BUSY;
    buffer[buffer_index++] = *rec;
    if (buffer_index >= RECORDS_PER_PAGE) return flush_page();
    return HAL_OK;
}

HAL_StatusTypeDef save_push_from_main_ts(uint8_t t1, uint8_t t2, uint8_t t3,
                                         uint8_t h1, uint8_t h2, uint8_t h3,
                                         uint16_t adc12, uint8_t st,
                                         uint8_t reserved, uint32_t ts32) {
    DataRecord rec;
    rec.timestamp = (uint32_t)ts32;
    rec.temp[0] = t1; rec.temp[1] = t2; rec.temp[2] = t3;
    rec.hum[0] = h1; rec.hum[1] = h2; rec.hum[2] = h3;
    rec.adc_state = (adc12 & 0x0FFF) | ((st & 0x0F) << 12);
    (void)reserved;
    return Save_Append(&rec);
}

HAL_StatusTypeDef Save_Flush(void) {
    if (buffer_index == 0) return HAL_OK;
    return flush_page();
}

/* ===== Getter für ausgabe.c ===== */
uint16_t Save_GetSessionFlag(void) { return session_flag; }
uint32_t Save_GetStartPageIndex(void) { return start_page; }
uint32_t Save_GetNumPages(void) { return DATA_FLASH_NUM_PAGES; }
uint32_t Save_GetPageAddr(uint32_t i) { return page_index_to_addr(i); }
uint32_t Save_GetRecordsPerPage(void) { return RECORDS_PER_PAGE; }

/* ===== Lesezugriff ===== */
int Save_ReadPageHeader(uint32_t i, uint16_t *magic, uint16_t *flag) {
    if (i >= DATA_FLASH_NUM_PAGES) return -1;
    const PageHeader *h = (const PageHeader*)page_index_to_addr(i);
    if (magic) *magic = h->magic;
    if (flag)  *flag  = h->session_flag;
    return 0;
}

int Save_ReadRecord(uint32_t i, uint32_t rec_idx, DataRecord *out) {
    if (i >= DATA_FLASH_NUM_PAGES || rec_idx >= RECORDS_PER_PAGE) return -1;
    uint32_t addr = page_index_to_addr(i) + PAGE_HEADER_SIZE + rec_idx * sizeof(DataRecord);
    memcpy(out, (const void*)addr, sizeof(DataRecord));
    return 0;
}

int Save_RecordIsEmpty(const DataRecord *r) {
    return (r->timestamp == 0xFFFFFFFF);
}
